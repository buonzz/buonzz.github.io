---
layout: post
title: Using your own Custom Classes in Laravel 4
permalink: using-your-own-custom-classes-in-laravel-4
date: 2014-03-31 08:26:06.000000000 +08:00
categories:
- coding
tags: []
status: draft
type: post
published: false
meta:
  _edit_last: '2'
  _wpas_skip_1611607: '1'
author:
  login: Darwin
  email: buonzz@gmail.com
  display_name: Darwin
  first_name: Darwin
  last_name: Biler
---
<p>Let's say you have this Member class in a PHP file and you want to use it in Laravel application<br />
<script src="https://gist.github.com/buonzz/9881706.js"></script></p>
<p>In a plain PHP script, this can be used by:<br />
<script src="https://gist.github.com/buonzz/9881747.js"></script></p>
<p>What a straight-forward and efficient code isn't it?</p>
<p>In Laravel though, you should NOT be using your classes like that. There are tons of bells and whistles involved on doing such a very simple task above in Laravel 4, but it's worth it. Let's go over with the problems first associated with the simple method we had used above so you can get a better picture why its worth knowing how Laravel 4 does it stuffs:</p>
<ul>
<li>What if someone created a Helloworld class and include it as well in script? It will conflict for sure, there is no way for both of your class to exist in a single application</li>
<li>If your class is being used by many applications, when you need to change the codes in the class, you have to manually distribute the class file again to all applications</li>
<li>You cannot test the class itself w/o hitting real databases (in real world, classes will use some external data somehow) or using real user data</li>
<li>What if the creation of the class is so complex, that it requires connecting to multiple databases, 3rd party APIS</li>
</ul>
<p>As you can see, a simple PHP require statement might work for very simple projects but sucks when you have a large-scale application.</p>
<p>In Laravel, you will most likely do it this way in a full-blown setup (Yes, there are some steps optional in here but I strongly recommend you follow these steps)</p>
<ul>
<li>Create a Composer library to hold all your custom class (some prefer to not externalize it in a dedicated library, but I personally prefer it should be)</li>
<li>Develop your classes inside the Composer Library</li>
<li>Perform Unit-Testing of all of your classes inside the Library</li>
<li>Create a Laravel Service Provider class for your Composer Library classes</li>
<li>Inside your Service Provider class,  bind your custom classes to the IoC Container</li>
<li>Create a Facade class for your custom class</li>
<li>Use the Facade class name in your Laravel application</li>
</ul>
<p>Wtf! Boy, that escalated too quickly!</p>
<p>And why the hell anybody would do those steps in exchange of simply requiring the damn php file?  ( in case you had asked )</p>
<p>The short answer is:  extendability, testability and compliance to best-practices</p>
<p>The long answer is, ... uhm well Its quite long that I have to break it down to multiple post.</p>
<p>In this series of posts, we will go through why and how these steps are necessary, what are the benefits of using this both in your skillset and the to the software itself that you are writing and as we can see in the end, why these concepts is crucial to the Laravel's own existence...<br />
(read the above  paragraph in Morgan Freeman's voice)</p>
